import deepmerge from 'deepmerge';
// Cannot import from the @ngrx/store package due to a module resolution issue.
// See Issue #206.
const INIT_ACTION = '@ngrx/store/init';
const UPDATE_ACTION = '@ngrx/store/update-reducers';
const detectDate = /(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})/;
// correctly parse dates from local storage
export const dateReviver = (_key, value) => {
    if (typeof value === 'string' && detectDate.test(value)) {
        return new Date(value);
    }
    return value;
};
const dummyReviver = (_key, value) => value;
const checkIsBrowserEnv = () => {
    return typeof window !== 'undefined';
};
const validateStateKeys = (keys) => {
    return keys.map((key) => {
        let attr = key;
        if (typeof key === 'object') {
            attr = Object.keys(key)[0];
        }
        if (typeof attr !== 'string') {
            throw new TypeError(`localStorageSync Unknown Parameter Type: ` + `Expected type of string, got ${typeof attr}`);
        }
        return key;
    });
};
export const rehydrateApplicationState = (keys, storage, storageKeySerializer, restoreDates) => {
    return keys.reduce((acc, curr) => {
        let key = curr;
        let reviver = restoreDates ? dateReviver : dummyReviver;
        let deserialize;
        let decrypt;
        if (typeof key === 'object') {
            key = Object.keys(key)[0];
            // use the custom reviver function
            if (typeof curr[key] === 'function') {
                reviver = curr[key];
            }
            else {
                // use custom reviver function if available
                if (curr[key].reviver) {
                    reviver = curr[key].reviver;
                }
                // use custom serialize function if available
                if (curr[key].deserialize) {
                    deserialize = curr[key].deserialize;
                }
            }
            // Ensure that encrypt and decrypt functions are both present
            if (curr[key].encrypt && curr[key].decrypt) {
                if (typeof curr[key].encrypt === 'function' && typeof curr[key].decrypt === 'function') {
                    decrypt = curr[key].decrypt;
                }
                else {
                    console.error(`Either encrypt or decrypt is not a function on '${curr[key]}' key object.`);
                }
            }
            else if (curr[key].encrypt || curr[key].decrypt) {
                // Let know that one of the encryption functions is not provided
                console.error(`Either encrypt or decrypt function is not present on '${curr[key]}' key object.`);
            }
        }
        if (storage !== undefined) {
            let stateSlice = storage.getItem(storageKeySerializer(key));
            if (stateSlice) {
                // Use provided decrypt function
                if (decrypt) {
                    stateSlice = decrypt(stateSlice);
                }
                const isObjectRegex = new RegExp('{|\\[');
                let raw = stateSlice;
                if (stateSlice === 'null' || stateSlice === 'true' || stateSlice === 'false' || isObjectRegex.test(stateSlice.charAt(0))) {
                    raw = JSON.parse(stateSlice, reviver);
                }
                return Object.assign({}, acc, {
                    [key]: deserialize ? deserialize(raw) : raw,
                });
            }
        }
        return acc;
    }, {});
};
// Recursively traverse all properties of the existing slice as defined by the `filter` argument,
// and output the new object with extraneous properties removed.
function createStateSlice(existingSlice, filter) {
    return filter.reduce((memo, attr) => {
        if (typeof attr === 'string' || typeof attr === 'number') {
            const value = existingSlice?.[attr];
            if (value !== undefined) {
                memo[attr] = value;
            }
        }
        else {
            for (const key in attr) {
                if (Object.prototype.hasOwnProperty.call(attr, key)) {
                    const element = attr[key];
                    memo[key] = createStateSlice(existingSlice[key], element);
                }
            }
        }
        return memo;
    }, {});
}
export const syncStateUpdate = (state, keys, storage, storageKeySerializer, removeOnUndefined, syncCondition) => {
    if (syncCondition) {
        try {
            if (syncCondition(state) !== true) {
                return;
            }
        }
        catch (e) {
            // Treat TypeError as do not sync
            if (e instanceof TypeError) {
                return;
            }
            throw e;
        }
    }
    keys.forEach((key) => {
        let stateSlice = state[key];
        let replacer;
        let space;
        let encrypt;
        if (typeof key === 'object') {
            let name = Object.keys(key)[0];
            stateSlice = state[name];
            if (typeof stateSlice !== 'undefined' && key[name]) {
                // use serialize function if specified.
                if (key[name].serialize) {
                    stateSlice = key[name].serialize(stateSlice);
                }
                else {
                    // if serialize function is not specified filter on fields if an array has been provided.
                    let filter;
                    if (key[name].reduce) {
                        filter = key[name];
                    }
                    else if (key[name].filter) {
                        filter = key[name].filter;
                    }
                    if (filter) {
                        stateSlice = createStateSlice(stateSlice, filter);
                    }
                    // Check if encrypt and decrypt are present, also checked at this#rehydrateApplicationState()
                    if (key[name].encrypt && key[name].decrypt) {
                        if (typeof key[name].encrypt === 'function') {
                            encrypt = key[name].encrypt;
                        }
                    }
                    else if (key[name].encrypt || key[name].decrypt) {
                        // If one of those is not present, then let know that one is missing
                        console.error(`Either encrypt or decrypt function is not present on '${key[name]}' key object.`);
                    }
                }
                /*
          Replacer and space arguments to pass to JSON.stringify.
          If these fields don't exist, undefined will be passed.
        */
                replacer = key[name].replacer;
                space = key[name].space;
            }
            key = name;
        }
        if (typeof stateSlice !== 'undefined' && storage !== undefined) {
            try {
                if (encrypt) {
                    // ensure that a string message is passed
                    stateSlice = encrypt(typeof stateSlice === 'string' ? stateSlice : JSON.stringify(stateSlice, replacer, space));
                }
                storage.setItem(storageKeySerializer(key), typeof stateSlice === 'string' ? stateSlice : JSON.stringify(stateSlice, replacer, space));
            }
            catch (e) {
                console.warn('Unable to save state to localStorage:', e);
            }
        }
        else if (typeof stateSlice === 'undefined' && removeOnUndefined && storage !== undefined) {
            try {
                storage.removeItem(storageKeySerializer(key));
            }
            catch (e) {
                console.warn(`Exception on removing/cleaning undefined '${key}' state`, e);
            }
        }
    });
};
// Default merge strategy is a full deep merge.
export const defaultMergeReducer = (state, rehydratedState, action) => {
    if ((action.type === INIT_ACTION || action.type === UPDATE_ACTION) && rehydratedState) {
        const overwriteMerge = (destinationArray, sourceArray, options) => sourceArray;
        const options = {
            arrayMerge: overwriteMerge,
        };
        state = deepmerge(state, rehydratedState, options);
    }
    return state;
};
export const localStorageSync = (config) => (reducer) => {
    if ((config.storage === undefined && !config.checkStorageAvailability) ||
        (config.checkStorageAvailability && checkIsBrowserEnv())) {
        config.storage = localStorage || window.localStorage;
    }
    if (config.storageKeySerializer === undefined) {
        config.storageKeySerializer = (key) => key;
    }
    if (config.restoreDates === undefined) {
        config.restoreDates = true;
    }
    // Use default merge reducer.
    let mergeReducer = config.mergeReducer;
    if (mergeReducer === undefined || typeof mergeReducer !== 'function') {
        mergeReducer = defaultMergeReducer;
    }
    const stateKeys = validateStateKeys(config.keys);
    const rehydratedState = config.rehydrate
        ? rehydrateApplicationState(stateKeys, config.storage, config.storageKeySerializer, config.restoreDates)
        : undefined;
    return function (state, action) {
        let nextState;
        // If state arrives undefined, we need to let it through the supplied reducer
        // in order to get a complete state as defined by user
        if (action.type === INIT_ACTION && !state) {
            nextState = reducer(state, action);
        }
        else {
            nextState = { ...state };
        }
        // Merge the store state with the rehydrated state using
        // either a user-defined reducer or the default.
        nextState = mergeReducer(nextState, rehydratedState, action);
        nextState = reducer(nextState, action);
        if (action.type !== INIT_ACTION) {
            syncStateUpdate(nextState, stateKeys, config.storage, config.storageKeySerializer, config.removeOnUndefined, config.syncCondition);
        }
        return nextState;
    };
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9saWIvc3JjL2xpYi9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLFNBQVMsTUFBTSxXQUFXLENBQUM7QUFFbEMsK0VBQStFO0FBQy9FLGtCQUFrQjtBQUNsQixNQUFNLFdBQVcsR0FBRyxrQkFBa0IsQ0FBQztBQUN2QyxNQUFNLGFBQWEsR0FBRyw2QkFBNkIsQ0FBQztBQUVwRCxNQUFNLFVBQVUsR0FBRyxpREFBaUQsQ0FBQztBQUVyRSwyQ0FBMkM7QUFDM0MsTUFBTSxDQUFDLE1BQU0sV0FBVyxHQUFHLENBQUMsSUFBWSxFQUFFLEtBQVUsRUFBRSxFQUFFO0lBQ3BELElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxJQUFJLFVBQVUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQztRQUN0RCxPQUFPLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzNCLENBQUM7SUFDRCxPQUFPLEtBQUssQ0FBQztBQUNqQixDQUFDLENBQUM7QUFFRixNQUFNLFlBQVksR0FBRyxDQUFDLElBQVksRUFBRSxLQUFVLEVBQUUsRUFBRSxDQUFDLEtBQUssQ0FBQztBQUV6RCxNQUFNLGlCQUFpQixHQUFHLEdBQUcsRUFBRTtJQUMzQixPQUFPLE9BQU8sTUFBTSxLQUFLLFdBQVcsQ0FBQztBQUN6QyxDQUFDLENBQUM7QUFFRixNQUFNLGlCQUFpQixHQUFHLENBQUMsSUFBVSxFQUFFLEVBQUU7SUFDckMsT0FBUSxJQUFjLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUU7UUFDL0IsSUFBSSxJQUFJLEdBQUcsR0FBRyxDQUFDO1FBRWYsSUFBSSxPQUFPLEdBQUcsS0FBSyxRQUFRLEVBQUUsQ0FBQztZQUMxQixJQUFJLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztR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QUFNLENBQUM7WUFDSixTQUFTLEdBQUcsRUFBRSxHQUFHLEtBQUssRUFBRSxDQUFDO1FBQzdCLENBQUM7UUFFRCx3REFBd0Q7UUFDeEQsZ0RBQWdEO1FBQ2hELFNBQVMsR0FBRyxZQUFZLENBQUMsU0FBUyxFQUFFLGVBQWUsRUFBRSxNQUFNLENBQUMsQ0FBQztRQUU3RCxTQUFTLEdBQUcsT0FBTyxDQUFDLFNBQVMsRUFBRSxNQUFNLENBQUMsQ0FBQztRQUV2QyxJQUFJLE1BQU0sQ0FBQyxJQUFJLEtBQUssV0FBVyxFQUFFLENBQUM7WUFDOUIsZUFBZSxDQUNYLFNBQVMsRUFDVCxTQUFTLEVBQ1QsTUFBTSxDQUFDLE9BQU8sRUFDZCxNQUFNLENBQUMsb0JBQXdELEVBQy9ELE1BQU0sQ0FBQyxpQkFBaUIsRUFDeEIsTUFBTSxDQUFDLGFBQWEsQ0FDdkIsQ0FBQztRQUNOLENBQUM7UUFFRCxPQUFPLFNBQVMsQ0FBQztJQUNyQixDQUFDLENBQUM7QUFDTixDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZGVlcG1lcmdlIGZyb20gJ2RlZXBtZXJnZSc7XG5cbi8vIENhbm5vdCBpbXBvcnQgZnJvbSB0aGUgQG5ncngvc3RvcmUgcGFja2FnZSBkdWUgdG8gYSBtb2R1bGUgcmVzb2x1dGlvbiBpc3N1ZS5cbi8vIFNlZSBJc3N1ZSAjMjA2LlxuY29uc3QgSU5JVF9BQ1RJT04gPSAnQG5ncngvc3RvcmUvaW5pdCc7XG5jb25zdCBVUERBVEVfQUNUSU9OID0gJ0BuZ3J4L3N0b3JlL3VwZGF0ZS1yZWR1Y2Vycyc7XG5cbmNvbnN0IGRldGVjdERhdGUgPSAvKFxcZHs0fSktKFxcZHsyfSktKFxcZHsyfSlUKFxcZHsyfSk6KFxcZHsyfSk6KFxcZHsyfSkvO1xuXG4vLyBjb3JyZWN0bHkgcGFyc2UgZGF0ZXMgZnJvbSBsb2NhbCBzdG9yYWdlXG5leHBvcnQgY29uc3QgZGF0ZVJldml2ZXIgPSAoX2tleTogc3RyaW5nLCB2YWx1ZTogYW55KSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgZGV0ZWN0RGF0ZS50ZXN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG5jb25zdCBkdW1teVJldml2ZXIgPSAoX2tleTogc3RyaW5nLCB2YWx1ZTogYW55KSA9PiB2YWx1ZTtcblxuY29uc3QgY2hlY2tJc0Jyb3dzZXJFbnYgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xufTtcblxuY29uc3QgdmFsaWRhdGVTdGF0ZUtleXMgPSAoa2V5czogS2V5cykgPT4ge1xuICAgIHJldHVybiAoa2V5cyBhcyBhbnlbXSkubWFwKChrZXkpID0+IHtcbiAgICAgICAgbGV0IGF0dHIgPSBrZXk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBhdHRyID0gT2JqZWN0LmtleXMoa2V5KVswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgYXR0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgYGxvY2FsU3RvcmFnZVN5bmMgVW5rbm93biBQYXJhbWV0ZXIgVHlwZTogYCArIGBFeHBlY3RlZCB0eXBlIG9mIHN0cmluZywgZ290ICR7dHlwZW9mIGF0dHJ9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5O1xuICAgIH0pO1xufTtcblxuZXhwb3J0IGNvbnN0IHJlaHlkcmF0ZUFwcGxpY2F0aW9uU3RhdGUgPSAoXG4gICAga2V5czogS2V5cyxcbiAgICBzdG9yYWdlOiBTdG9yYWdlLFxuICAgIHN0b3JhZ2VLZXlTZXJpYWxpemVyOiAoa2V5OiBzdHJpbmcpID0+IHN0cmluZyxcbiAgICByZXN0b3JlRGF0ZXM6IGJvb2xlYW5cbikgPT4ge1xuICAgIHJldHVybiAoa2V5cyBhcyBhbnlbXSkucmVkdWNlKChhY2MsIGN1cnIpID0+IHtcbiAgICAgICAgbGV0IGtleSA9IGN1cnI7XG4gICAgICAgIGxldCByZXZpdmVyID0gcmVzdG9yZURhdGVzID8gZGF0ZVJldml2ZXIgOiBkdW1teVJldml2ZXI7XG4gICAgICAgIGxldCBkZXNlcmlhbGl6ZTogKGFyZzA6IHN0cmluZykgPT4gYW55O1xuICAgICAgICBsZXQgZGVjcnlwdDogKGFyZzA6IHN0cmluZykgPT4gc3RyaW5nO1xuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAga2V5ID0gT2JqZWN0LmtleXMoa2V5KVswXTtcbiAgICAgICAgICAgIC8vIHVzZSB0aGUgY3VzdG9tIHJldml2ZXIgZnVuY3Rpb25cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3VycltrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV2aXZlciA9IGN1cnJba2V5XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdXNlIGN1c3RvbSByZXZpdmVyIGZ1bmN0aW9uIGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgIGlmIChjdXJyW2tleV0ucmV2aXZlcikge1xuICAgICAgICAgICAgICAgICAgICByZXZpdmVyID0gY3VycltrZXldLnJldml2ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHVzZSBjdXN0b20gc2VyaWFsaXplIGZ1bmN0aW9uIGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgIGlmIChjdXJyW2tleV0uZGVzZXJpYWxpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzZXJpYWxpemUgPSBjdXJyW2tleV0uZGVzZXJpYWxpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFbnN1cmUgdGhhdCBlbmNyeXB0IGFuZCBkZWNyeXB0IGZ1bmN0aW9ucyBhcmUgYm90aCBwcmVzZW50XG4gICAgICAgICAgICBpZiAoY3VycltrZXldLmVuY3J5cHQgJiYgY3VycltrZXldLmRlY3J5cHQpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGN1cnJba2V5XS5lbmNyeXB0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjdXJyW2tleV0uZGVjcnlwdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBkZWNyeXB0ID0gY3VycltrZXldLmRlY3J5cHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRWl0aGVyIGVuY3J5cHQgb3IgZGVjcnlwdCBpcyBub3QgYSBmdW5jdGlvbiBvbiAnJHtjdXJyW2tleV19JyBrZXkgb2JqZWN0LmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycltrZXldLmVuY3J5cHQgfHwgY3VycltrZXldLmRlY3J5cHQpIHtcbiAgICAgICAgICAgICAgICAvLyBMZXQga25vdyB0aGF0IG9uZSBvZiB0aGUgZW5jcnlwdGlvbiBmdW5jdGlvbnMgaXMgbm90IHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRWl0aGVyIGVuY3J5cHQgb3IgZGVjcnlwdCBmdW5jdGlvbiBpcyBub3QgcHJlc2VudCBvbiAnJHtjdXJyW2tleV19JyBrZXkgb2JqZWN0LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdG9yYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBzdGF0ZVNsaWNlID0gc3RvcmFnZS5nZXRJdGVtKHN0b3JhZ2VLZXlTZXJpYWxpemVyKGtleSkpO1xuICAgICAgICAgICAgaWYgKHN0YXRlU2xpY2UpIHtcbiAgICAgICAgICAgICAgICAvLyBVc2UgcHJvdmlkZWQgZGVjcnlwdCBmdW5jdGlvblxuICAgICAgICAgICAgICAgIGlmIChkZWNyeXB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlU2xpY2UgPSBkZWNyeXB0KHN0YXRlU2xpY2UpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGlzT2JqZWN0UmVnZXggPSBuZXcgUmVnRXhwKCd7fFxcXFxbJyk7XG4gICAgICAgICAgICAgICAgbGV0IHJhdyA9IHN0YXRlU2xpY2U7XG5cbiAgICAgICAgICAgICAgICBpZiAoc3RhdGVTbGljZSA9PT0gJ251bGwnIHx8IHN0YXRlU2xpY2UgPT09ICd0cnVlJyB8fCBzdGF0ZVNsaWNlID09PSAnZmFsc2UnIHx8IGlzT2JqZWN0UmVnZXgudGVzdChzdGF0ZVNsaWNlLmNoYXJBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmF3ID0gSlNPTi5wYXJzZShzdGF0ZVNsaWNlLCByZXZpdmVyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgYWNjLCB7XG4gICAgICAgICAgICAgICAgICAgIFtrZXldOiBkZXNlcmlhbGl6ZSA/IGRlc2VyaWFsaXplKHJhdykgOiByYXcsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG59O1xuXG4vLyBSZWN1cnNpdmVseSB0cmF2ZXJzZSBhbGwgcHJvcGVydGllcyBvZiB0aGUgZXhpc3Rpbmcgc2xpY2UgYXMgZGVmaW5lZCBieSB0aGUgYGZpbHRlcmAgYXJndW1lbnQsXG4vLyBhbmQgb3V0cHV0IHRoZSBuZXcgb2JqZWN0IHdpdGggZXh0cmFuZW91cyBwcm9wZXJ0aWVzIHJlbW92ZWQuXG5mdW5jdGlvbiBjcmVhdGVTdGF0ZVNsaWNlKGV4aXN0aW5nU2xpY2U6IGFueSwgZmlsdGVyOiAoc3RyaW5nIHwgbnVtYmVyIHwgS2V5Q29uZmlndXJhdGlvbiB8IE9wdGlvbnMpW10pIHtcbiAgICByZXR1cm4gZmlsdGVyLnJlZHVjZShcbiAgICAgICAgKG1lbW86IHsgW3g6IHN0cmluZ106IGFueTsgW3g6IG51bWJlcl06IGFueSB9LCBhdHRyOiBzdHJpbmcgfCBudW1iZXIgfCBLZXlDb25maWd1cmF0aW9uIHwgT3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhdHRyID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgYXR0ciA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGV4aXN0aW5nU2xpY2U/LlthdHRyXTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBtZW1vW2F0dHJdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXR0ciwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGF0dHJba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lbW9ba2V5XSA9IGNyZWF0ZVN0YXRlU2xpY2UoZXhpc3RpbmdTbGljZVtrZXldLCBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZW1vO1xuICAgICAgICB9LFxuICAgICAgICB7fVxuICAgICk7XG59XG5cbmV4cG9ydCBjb25zdCBzeW5jU3RhdGVVcGRhdGUgPSAoXG4gICAgc3RhdGU6IGFueSxcbiAgICBrZXlzOiBLZXlzLFxuICAgIHN0b3JhZ2U6IFN0b3JhZ2UsXG4gICAgc3RvcmFnZUtleVNlcmlhbGl6ZXI6IChrZXk6IHN0cmluZyB8IG51bWJlcikgPT4gc3RyaW5nLFxuICAgIHJlbW92ZU9uVW5kZWZpbmVkOiBib29sZWFuLFxuICAgIHN5bmNDb25kaXRpb24/OiAoc3RhdGU6IGFueSkgPT4gYW55XG4pID0+IHtcbiAgICBpZiAoc3luY0NvbmRpdGlvbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHN5bmNDb25kaXRpb24oc3RhdGUpICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBUcmVhdCBUeXBlRXJyb3IgYXMgZG8gbm90IHN5bmNcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgVHlwZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGtleXMuZm9yRWFjaCgoa2V5OiBzdHJpbmcgfCBLZXlDb25maWd1cmF0aW9uIHwgT3B0aW9ucyB8ICgoa2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkpID0+IGFueSkpOiB2b2lkID0+IHtcbiAgICAgICAgbGV0IHN0YXRlU2xpY2UgPSBzdGF0ZVtrZXkgYXMgc3RyaW5nXTtcbiAgICAgICAgbGV0IHJlcGxhY2VyO1xuICAgICAgICBsZXQgc3BhY2U6IHN0cmluZyB8IG51bWJlcjtcbiAgICAgICAgbGV0IGVuY3J5cHQ7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBsZXQgbmFtZSA9IE9iamVjdC5rZXlzKGtleSlbMF07XG4gICAgICAgICAgICBzdGF0ZVNsaWNlID0gc3RhdGVbbmFtZV07XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RhdGVTbGljZSAhPT0gJ3VuZGVmaW5lZCcgJiYga2V5W25hbWVdKSB7XG4gICAgICAgICAgICAgICAgLy8gdXNlIHNlcmlhbGl6ZSBmdW5jdGlvbiBpZiBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgaWYgKGtleVtuYW1lXS5zZXJpYWxpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVTbGljZSA9IGtleVtuYW1lXS5zZXJpYWxpemUoc3RhdGVTbGljZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgc2VyaWFsaXplIGZ1bmN0aW9uIGlzIG5vdCBzcGVjaWZpZWQgZmlsdGVyIG9uIGZpZWxkcyBpZiBhbiBhcnJheSBoYXMgYmVlbiBwcm92aWRlZC5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGZpbHRlcjogS2V5Q29uZmlndXJhdGlvbltdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5W25hbWVdLnJlZHVjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyID0ga2V5W25hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleVtuYW1lXS5maWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlciA9IGtleVtuYW1lXS5maWx0ZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVTbGljZSA9IGNyZWF0ZVN0YXRlU2xpY2Uoc3RhdGVTbGljZSwgZmlsdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGVuY3J5cHQgYW5kIGRlY3J5cHQgYXJlIHByZXNlbnQsIGFsc28gY2hlY2tlZCBhdCB0aGlzI3JlaHlkcmF0ZUFwcGxpY2F0aW9uU3RhdGUoKVxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5W25hbWVdLmVuY3J5cHQgJiYga2V5W25hbWVdLmRlY3J5cHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5W25hbWVdLmVuY3J5cHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNyeXB0ID0ga2V5W25hbWVdLmVuY3J5cHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5W25hbWVdLmVuY3J5cHQgfHwga2V5W25hbWVdLmRlY3J5cHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIG9uZSBvZiB0aG9zZSBpcyBub3QgcHJlc2VudCwgdGhlbiBsZXQga25vdyB0aGF0IG9uZSBpcyBtaXNzaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBFaXRoZXIgZW5jcnlwdCBvciBkZWNyeXB0IGZ1bmN0aW9uIGlzIG5vdCBwcmVzZW50IG9uICcke2tleVtuYW1lXX0nIGtleSBvYmplY3QuYFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgUmVwbGFjZXIgYW5kIHNwYWNlIGFyZ3VtZW50cyB0byBwYXNzIHRvIEpTT04uc3RyaW5naWZ5LlxuICAgICAgICAgIElmIHRoZXNlIGZpZWxkcyBkb24ndCBleGlzdCwgdW5kZWZpbmVkIHdpbGwgYmUgcGFzc2VkLlxuICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHJlcGxhY2VyID0ga2V5W25hbWVdLnJlcGxhY2VyO1xuICAgICAgICAgICAgICAgIHNwYWNlID0ga2V5W25hbWVdLnNwYWNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBrZXkgPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZVNsaWNlICE9PSAndW5kZWZpbmVkJyAmJiBzdG9yYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGVuY3J5cHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5zdXJlIHRoYXQgYSBzdHJpbmcgbWVzc2FnZSBpcyBwYXNzZWRcbiAgICAgICAgICAgICAgICAgICAgc3RhdGVTbGljZSA9IGVuY3J5cHQoXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygc3RhdGVTbGljZSA9PT0gJ3N0cmluZycgPyBzdGF0ZVNsaWNlIDogSlNPTi5zdHJpbmdpZnkoc3RhdGVTbGljZSwgcmVwbGFjZXIsIHNwYWNlKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdG9yYWdlLnNldEl0ZW0oXG4gICAgICAgICAgICAgICAgICAgIHN0b3JhZ2VLZXlTZXJpYWxpemVyKGtleSBhcyBzdHJpbmcpLFxuICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygc3RhdGVTbGljZSA9PT0gJ3N0cmluZycgPyBzdGF0ZVNsaWNlIDogSlNPTi5zdHJpbmdpZnkoc3RhdGVTbGljZSwgcmVwbGFjZXIsIHNwYWNlKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdVbmFibGUgdG8gc2F2ZSBzdGF0ZSB0byBsb2NhbFN0b3JhZ2U6JywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHN0YXRlU2xpY2UgPT09ICd1bmRlZmluZWQnICYmIHJlbW92ZU9uVW5kZWZpbmVkICYmIHN0b3JhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzdG9yYWdlLnJlbW92ZUl0ZW0oc3RvcmFnZUtleVNlcmlhbGl6ZXIoa2V5IGFzIHN0cmluZykpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgRXhjZXB0aW9uIG9uIHJlbW92aW5nL2NsZWFuaW5nIHVuZGVmaW5lZCAnJHtrZXl9JyBzdGF0ZWAsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG4vLyBEZWZhdWx0IG1lcmdlIHN0cmF0ZWd5IGlzIGEgZnVsbCBkZWVwIG1lcmdlLlxuZXhwb3J0IGNvbnN0IGRlZmF1bHRNZXJnZVJlZHVjZXIgPSAoc3RhdGU6IGFueSwgcmVoeWRyYXRlZFN0YXRlOiBhbnksIGFjdGlvbjogYW55KSA9PiB7XG4gICAgaWYgKChhY3Rpb24udHlwZSA9PT0gSU5JVF9BQ1RJT04gfHwgYWN0aW9uLnR5cGUgPT09IFVQREFURV9BQ1RJT04pICYmIHJlaHlkcmF0ZWRTdGF0ZSkge1xuICAgICAgICBjb25zdCBvdmVyd3JpdGVNZXJnZSA9IChkZXN0aW5hdGlvbkFycmF5OiBhbnksIHNvdXJjZUFycmF5OiBhbnksIG9wdGlvbnM6IGFueSkgPT4gc291cmNlQXJyYXk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnM6IGRlZXBtZXJnZS5PcHRpb25zID0ge1xuICAgICAgICAgICAgYXJyYXlNZXJnZTogb3ZlcndyaXRlTWVyZ2UsXG4gICAgICAgIH07XG5cbiAgICAgICAgc3RhdGUgPSBkZWVwbWVyZ2Uoc3RhdGUsIHJlaHlkcmF0ZWRTdGF0ZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YXRlO1xufTtcblxuZXhwb3J0IGNvbnN0IGxvY2FsU3RvcmFnZVN5bmMgPSAoY29uZmlnOiBMb2NhbFN0b3JhZ2VDb25maWcpID0+IChyZWR1Y2VyOiBhbnkpID0+IHtcbiAgICBpZiAoXG4gICAgICAgIChjb25maWcuc3RvcmFnZSA9PT0gdW5kZWZpbmVkICYmICFjb25maWcuY2hlY2tTdG9yYWdlQXZhaWxhYmlsaXR5KSB8fFxuICAgICAgICAoY29uZmlnLmNoZWNrU3RvcmFnZUF2YWlsYWJpbGl0eSAmJiBjaGVja0lzQnJvd3NlckVudigpKVxuICAgICkge1xuICAgICAgICBjb25maWcuc3RvcmFnZSA9IGxvY2FsU3RvcmFnZSB8fCB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICAgIH1cblxuICAgIGlmIChjb25maWcuc3RvcmFnZUtleVNlcmlhbGl6ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25maWcuc3RvcmFnZUtleVNlcmlhbGl6ZXIgPSAoa2V5KSA9PiBrZXk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5yZXN0b3JlRGF0ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25maWcucmVzdG9yZURhdGVzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBVc2UgZGVmYXVsdCBtZXJnZSByZWR1Y2VyLlxuICAgIGxldCBtZXJnZVJlZHVjZXIgPSBjb25maWcubWVyZ2VSZWR1Y2VyO1xuXG4gICAgaWYgKG1lcmdlUmVkdWNlciA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBtZXJnZVJlZHVjZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgbWVyZ2VSZWR1Y2VyID0gZGVmYXVsdE1lcmdlUmVkdWNlcjtcbiAgICB9XG5cbiAgICBjb25zdCBzdGF0ZUtleXMgPSB2YWxpZGF0ZVN0YXRlS2V5cyhjb25maWcua2V5cyk7XG4gICAgY29uc3QgcmVoeWRyYXRlZFN0YXRlID0gY29uZmlnLnJlaHlkcmF0ZVxuICAgICAgICA/IHJlaHlkcmF0ZUFwcGxpY2F0aW9uU3RhdGUoc3RhdGVLZXlzLCBjb25maWcuc3RvcmFnZSwgY29uZmlnLnN0b3JhZ2VLZXlTZXJpYWxpemVyLCBjb25maWcucmVzdG9yZURhdGVzKVxuICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGU6IGFueSwgYWN0aW9uOiBhbnkpIHtcbiAgICAgICAgbGV0IG5leHRTdGF0ZTogYW55O1xuXG4gICAgICAgIC8vIElmIHN0YXRlIGFycml2ZXMgdW5kZWZpbmVkLCB3ZSBuZWVkIHRvIGxldCBpdCB0aHJvdWdoIHRoZSBzdXBwbGllZCByZWR1Y2VyXG4gICAgICAgIC8vIGluIG9yZGVyIHRvIGdldCBhIGNvbXBsZXRlIHN0YXRlIGFzIGRlZmluZWQgYnkgdXNlclxuICAgICAgICBpZiAoYWN0aW9uLnR5cGUgPT09IElOSVRfQUNUSU9OICYmICFzdGF0ZSkge1xuICAgICAgICAgICAgbmV4dFN0YXRlID0gcmVkdWNlcihzdGF0ZSwgYWN0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHRTdGF0ZSA9IHsgLi4uc3RhdGUgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1lcmdlIHRoZSBzdG9yZSBzdGF0ZSB3aXRoIHRoZSByZWh5ZHJhdGVkIHN0YXRlIHVzaW5nXG4gICAgICAgIC8vIGVpdGhlciBhIHVzZXItZGVmaW5lZCByZWR1Y2VyIG9yIHRoZSBkZWZhdWx0LlxuICAgICAgICBuZXh0U3RhdGUgPSBtZXJnZVJlZHVjZXIobmV4dFN0YXRlLCByZWh5ZHJhdGVkU3RhdGUsIGFjdGlvbik7XG5cbiAgICAgICAgbmV4dFN0YXRlID0gcmVkdWNlcihuZXh0U3RhdGUsIGFjdGlvbik7XG5cbiAgICAgICAgaWYgKGFjdGlvbi50eXBlICE9PSBJTklUX0FDVElPTikge1xuICAgICAgICAgICAgc3luY1N0YXRlVXBkYXRlKFxuICAgICAgICAgICAgICAgIG5leHRTdGF0ZSxcbiAgICAgICAgICAgICAgICBzdGF0ZUtleXMsXG4gICAgICAgICAgICAgICAgY29uZmlnLnN0b3JhZ2UsXG4gICAgICAgICAgICAgICAgY29uZmlnLnN0b3JhZ2VLZXlTZXJpYWxpemVyIGFzIChrZXk6IHN0cmluZyB8IG51bWJlcikgPT4gc3RyaW5nLFxuICAgICAgICAgICAgICAgIGNvbmZpZy5yZW1vdmVPblVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBjb25maWcuc3luY0NvbmRpdGlvblxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXh0U3RhdGU7XG4gICAgfTtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9jYWxTdG9yYWdlQ29uZmlnIHtcbiAgICBrZXlzOiBLZXlzO1xuICAgIHJlaHlkcmF0ZT86IGJvb2xlYW47XG4gICAgc3RvcmFnZT86IFN0b3JhZ2U7XG4gICAgcmVtb3ZlT25VbmRlZmluZWQ/OiBib29sZWFuO1xuICAgIHJlc3RvcmVEYXRlcz86IGJvb2xlYW47XG4gICAgc3RvcmFnZUtleVNlcmlhbGl6ZXI/OiAoa2V5OiBzdHJpbmcpID0+IHN0cmluZztcbiAgICBzeW5jQ29uZGl0aW9uPzogKHN0YXRlOiBhbnkpID0+IGFueTtcbiAgICBjaGVja1N0b3JhZ2VBdmFpbGFiaWxpdHk/OiBib29sZWFuO1xuICAgIG1lcmdlUmVkdWNlcj86IChzdGF0ZTogYW55LCByZWh5ZHJhdGVkU3RhdGU6IGFueSwgYWN0aW9uOiBhbnkpID0+IGFueTtcbn1cblxuaW50ZXJmYWNlIEtleUNvbmZpZ3VyYXRpb24ge1xuICAgIFtrZXk6IHN0cmluZ106IHN0cmluZ1tdIHwgbnVtYmVyW10gfCBLZXlDb25maWd1cmF0aW9uW10gfCBPcHRpb25zIHwgKChrZXk6IHN0cmluZywgdmFsdWU6IGFueSkgPT4gYW55KTtcbn1cblxuaW50ZXJmYWNlIE9wdGlvbnMge1xuICAgIHNlcmlhbGl6ZT86IChzdGF0ZTogYW55KSA9PiBhbnk7XG4gICAgZGVzZXJpYWxpemU/OiAoc3RhdGU6IGFueSkgPT4gYW55O1xuICAgIHJldml2ZXI/OiAoa2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkpID0+IGFueTtcbiAgICByZXBsYWNlcj86ICgoa2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkpID0+IGFueSkgfCBzdHJpbmdbXTtcbiAgICBlbmNyeXB0PzogKG1lc3NhZ2U6IHN0cmluZykgPT4gc3RyaW5nO1xuICAgIGRlY3J5cHQ/OiAobWVzc2FnZTogc3RyaW5nKSA9PiBzdHJpbmc7XG4gICAgZmlsdGVyPzogc3RyaW5nW107XG4gICAgc3BhY2U/OiBzdHJpbmcgfCBudW1iZXI7XG59XG5cbmV4cG9ydCB0eXBlIEtleXMgPSAoS2V5Q29uZmlndXJhdGlvbiB8IE9wdGlvbnN8IHN0cmluZylbXTtcbiJdfQ==